# JVM基础

## 1.JVM运行时区域

### 方法区

- 加载的类信息，常量，静态变量，即时编译后的代码数据

	- JDK1.8以后应该是换成了元空间，占用的虚拟内存

### 堆

- 内存区域最大的一块，所有线程共享，几乎所有的对象实例都是在堆分配

### 方法栈

- 用于存储局部变量表、操作数栈、动态链接、方法出口等信息

### 程序计数器

- 当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成

### 本地方法栈

- 与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的

	- 应该是会去找dll文件运行

### 图：

## 2.深拷贝和浅拷贝(非必考)

### 深拷贝

- 是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存

### 浅拷贝

- 只是增加了一个指针指向已存在的内存地址

	- 在计算机中开辟一块新的内存地址用于存放复制的对象。

		- 仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。

## 3.堆栈的区别(非必考)

### 物理地址

- 堆

	- 堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）

- 栈

	- 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

### 内存分别

- 堆

	- 堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。

- 栈

	- 栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。

### 存放的内容

- 堆

	- 堆存放的是对象的实例和数组。因此该区更关注的是数据的存储

		- 静态变量放在方法区
		- 静态的对象还是放在堆

- 栈

	- 栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

### 程序的可见度

- 堆

	- 堆对于整个应用程序都是共享、可见的。

- 栈

	- 栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。

## 4.虚拟机遇到new指令

### 1.先检查类是否加载，如果没有执行相应的类加载

### 2.类加载后，接下来分配内存空间

### 3.检查内存是否规整，采用指针碰撞的方式，如果不是规整的，就从空闲列表中分配，叫做空闲列表方式

### 4.划分内存的时候还需要考虑一件事情，并发，采用CAS处理或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。

### 5.内存空间初始化操作，设置元信息，hash码

## 5.内存分配的两种方式

### 指针碰撞

- 如果内存都是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配的内存由指针挪动一段与对象大小相等的距离

### 空闲列表

- 如果不规整，已使用的内存和空闲内存相互交错，虚拟机必须维护一个列表来记录那些内存是可用的，在分配的时候找到足够大的内存分配给对象

## 6.对象访问定位

### 句柄访问

- (过时的方式)堆中划分一块区域来作为句柄池，维护对象实例指针和对象类型数据

优势：稳定的句柄内存地址，对象移动时，只需要改变句柄中实例数据指针

	- 图：

### 直接指针

- (目前主要)直接就是引用的对象实例数据，实例数据中包含对象类型数据

速度更快，节省了一次指针定位的时间开销。

	- 图：

## 7.内存泄漏

### 内存泄漏指不在使用的对象或者变量一直占据内内存。GC无法回收的情况。

java内存泄露的原因：长生命周期的对象持有短生命周期的对象的引用，导致内存泄漏。尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。

## 8.java垃圾回收(GC)

### 简述：
Java开发不需要显示的释放对象的内存，而是由虚拟机自行执行，垃圾回收先线程，正常情况下不会执行，只有在虚拟机空闲的时候或者内存不足的时候才会执行，扫描那些没有被引用的对象，进行回收。

### 垃圾回收的算法

- 1.标记-清除算法

	- 标记无用对象进行回收

		- 缺点：效率不高，无法清除垃圾碎片

			- 

- 2.复制算法

	- 将容量划分为两个大小相等的内存区域，当一块用完了的时候将存活的对象复制到另一块区域，将已使用的内存区域全部清理掉。

		- 缺点：内存使用率只有原来的一半

			- 

- 3.标记-整理算法

	- 标记无用对象，然后将存活的对象都往一段移动，清理掉端边界以外的内存

		- 缺点：局部移动对象，一定程度上影响了效率

			- 

- 4.分代(不是算法，只是根据不同的内存区域选择最优算法)

	- 根据对象存活的生命周期把不同的内存区域划分为几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记整理，集齐前几代垃圾回收器，目前最优方案

		- 

			- -XX:SurvivorRatio=8：设置新生代和Surviver比例为8:2，8全部是新生代的Surviver占两个，一共10

### 问题

- 1.垃圾回收的基本原理？

	- GC采用有向图的方式记录和管理堆(heap)中的所有对象，确定哪些对象时可达的，那些时不可达的，对不可达的对象进行GC回收

- 2.如何手动GC？

	- system.gc()方法通知虚拟机GC，java语言并不一定能保证GC的执行

- 3.怎么判断是否可以回收？

	- 1.引用计数法

		- 为每一个对象创建一个引用计数器，有对象引用+1，没有对象引用-1，计数器为0时就会被回收。缺点是不能解决相互引用问题

	- 2.可达性分析算法

		- 从GC-root开始向下搜索，搜索走过的路径被称为引用链。当一个对象没有任何引用链时证明可以被回收。

- 4.方法区(也叫永久代，但是不合适)会被垃圾回收吗？

	- 一般来说不会，但是永久代满了，或者超过临界值了，会触发完全垃圾回收full gc，所以方法区也是可以被垃圾回收的，唯一没有被回收的区域就是程序计数器

- 5.有哪几种垃圾回收器？

	- 新生代收集器

		- 1.Serial收集器

			- 新生代单线程收集器，标记和清理都是单线程，优点是简单高效

		- 2.ParNew收集器

			- 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现

		- 3.Parallel Scavenge收集器

			- 新生代并行收集器，追求高吞吐量，高效利用 CPU。

	- 老年代收集器

		- 1.Serial Old收集器(标记-整理算法)

			- 老年代单线程收集器，Serial收集器的老年代版本

		- 2.Parallel Old收集器 (标记-整理算法)

			- 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本

		- 3.CMS(Concurrent Mark Sweep)收集器(标记-清除算法)

			- 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。

				- 以牺牲吞吐量代价，获得最短回收停顿时间为目标的垃圾收集器。对于服务器响应速度的应用上比较合适。可以在JVM启动参数加上"-XX:+UseConcMarkSweepGC"来指定使用CMS垃圾收集器
				- CMS使用标记清除算法，会产生大量不连续的空间内存碎片。当剩余内存不满足运行要求时，系统将会出现Concurrent Mode Failure，临时CMS会采用Serial Old回收器进行垃圾清除，此时性能会降低

		- 4.G1(Garbage First)收集器 (标记-整理算法)

			- Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

				- 

- 6.分代收集器是怎么工作的？

	- 1.分代收集器应该分为老年代和新生代两个区，新生代默认占比1/3，老生代默认占比2/3。
	- 2.新生代使用的是复制算法，新生代有三个区：Eden、To Survivor、From Survivor

		- 执行流程

			-  1.把Eden和From Survivor存活的对象放到To Survivor
			- 2.清空Eden和From Survivor分区
			- 3.From Survivor和To Survivor分区交换，Form Survivor变成To Survivor，To Survivor变成From Survivor

				- 这两个区域每次移动都存活的对象，年龄+1，年龄达到默认15时，升级为老年代。大对象直接进入老年代。

	- 3.老年代当空间占比达到临界值后出发全局垃圾回收，一般使用标记整理的执行算法

## 9.java中的引用类型

### 1.强引用

- 发生gc的时候不会被回收

### 2.软引用

- 有用但不是必须的对象，在发生溢出之前会被回收

### 3.弱引用

- 有用但是不是必须的对象，在下一次gc之前会被回收

### 4.虚引用

- 无法通过虚引用获取对象，用PhantomReference实现虚引用，虚引用的用途时在gc时返回一个通知

## 10.内存分配策略

### 介绍

- 通常说的都是在堆上分配，某些场景也会在栈上分配。对象主要分配在新生代的Eden区，如果启动了本地线程缓冲，将按照线程有现在TLAB上分配。少数情况也会直接在老年代上分配。分配规则不是百分百固定的。取决于垃圾回收器和虚拟机参数设置

### 虚拟机对内存的分配遵循以下规则

- 1.对象优先在Eden区分配

	- 没有足够内存时会进行minor GC

		- 此时如果新生的对象无法在 Eden 区创建（Eden 区无法容纳) 就会触发一次Young GC 此时会将 From Survivor 区与Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 To Survivor 区并且将From Survivor区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将From Survivor 区 和 To Survivor区交换。

- 2.大对象直接进入老年代
- 3.长期存活的对象进入老年代

## 11.类加载机制

### JVM加载Class文件的原理机制

- 简介

	- java中所有类，都需要由类加载到JVM中才能运行，类加载器本身也是一个类，它的工作就是把class文件从硬盘中读取到内存中。

java类的加载是动态的，并不会一次性加载所有的类再运行，而是保证程序运行的基础类(像基类)完全加载到JVM中，其他的类用到的时候才加载到内存中。为了节省内存的开销。

- 类的装载方式

	- 1.隐式装载

		- 运行过程中出现new等方式生成对象时，隐式调用类装载器加载对应类到JVM中

	- 2.显示装载

		- 通过Class.forName等方法，显示加载需要的类

- 类加载器

	- 1.启动类加载器

		- 加载java核心类库，无法被java程序直接引用

	- 2.扩展类加载器

		- 加载java扩展库

	- 3.系统类加载器

		- 根据java应用类路径(ClASSPATH)来加载java类

	- 4.用户自定义类加载器

- 什么叫做双亲委派机制？

	- 如果一个类加载器收到了类的加载请求，首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载，只有当父加载无法完成加载请求(搜索方位内找不到)时，子加载器才会尝试去加载类
	- 如果没有双亲委派机制，同一个类可能就会被多个类加载器加载，如此类就可能会被识别为两个不同的类，相互赋值时问题就会出现
	- 越是父级的类加载器扫描的范围越小，也因此提升了性能

## 12.JVM调优工具

### 自带了很多监控工具，都在bin目录下最常用的

- 1.jconsole

	- 用于对jvm中的内存、线程和类监控

- 2.jvisualvm

	- JDK自带的全性能分析工具，可以分析：内存快照、程序死锁、监控内存的变化、gc变化等

## 13.常用的JVM调优参数

### -Xms2g：初始化堆大小为2g

### -Xmx2g：堆最大内存为2g

###  -Xmn5120m：年轻代的大小

### -XX:NewRatio=4：设置新生代和老年代的比例为1:4

### -XX:SurvivorRatio=8：设置Eden和Surviver比例为8:2

### -XX:+UseParNewGC：指定使用ParNew+Serial Old垃圾回收器组合

### -XX:+UseParallelOldGC：Parallel Scavenge收集器(复制算法)+Parallel Old收集器 (标记-整理算法)

### -XX:+UseConcMarkSweepGC：指定使用CMS+Serial Old垃圾回收器组合

### -XX:+PrintGC：开启打印gc信息

### -XX:+PrintGCDetails：打印gc详细信息

### -XX:+PrintCommandLineFlags ：查看使用的垃圾回收器

### 问题

问题引入：

-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3，,其最小内存值和Survivor区总大小分别是（10240m    2048m）；

解析：

-Xmx：最大堆大小

-Xms：初始堆大小

-Xmn:年轻代大小

-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值

年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。

-Xms初始堆大小即最小内存值为10240m。



