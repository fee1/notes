# IO基础

## java中IO流分为几种

### 1.按流的流向分，可以分为输入流输出流

### 2.按操作单元分，可以分为字节流和字符流

### 3.按照流的角色分，可以分为节点流和处理流

## 流的图分类

### 按操作凡是分类图：

### 按操作对象分类图：

## BIO/NIO/AIO有什么区别

### 简答：

- BIO：Block IO同步阻塞式IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
- NIO：Non IO同步非阻塞IO，是传统IO的升级，客户端和服务端就是用过Channel(通道)通讯，实现了多路复用。
- AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制。

### 详细：

- BIO(Blocking I/O)：同步阻塞IO模式，数据的读写必须阻塞在一个线程内等待其完成。在活动连接数不是特别高(小于单机1000)的情况下，可以考虑这种模型，可以让每一个链接专注于自己的IO并且编程模型简单，不用考虑系统的过载、限流等问题。现线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级别的链接的时候，传统的BIO模型是无能为力的。因此，我们需要一种更高效的IO处理模型来应对更高的并发量。
- NIO(NEW I/O)：NIO是一种同步非阻塞的IO模型，在JAVA1.4中引入了NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了于传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性不好，非阻塞正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞IO来提升开发速率和更好的维护性；对于高负载、高并发的(网络)应用，应使用NIO的非阻塞模式来开发
- AIO(Asynchronous I/O)：AIO也就是NIO2.在Java7中引入了NIO的高津版NIO2，它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在哪里，当后台处理完成，操作系统会通知相应的线程进行后续操作。AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好是，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说AIO的应用还不是很广泛，Netty之前也尝试使用过AIO，不过又放弃了。

## Files的常用方法

### Files.exists()：检测文件路径是否存在

### Files.createFile()：创建文件

### Files.createDirectory()：创建文件夹

### Files.delete()：删除一个文件或目录

### Files.copy()：复制文件

### Files.moves()：移动文件

### Files.size()：查看文件个数

### Files.read()：读取文件

### Files.write()：写入文件

