# 消息中间件MQ与RabbitMQ基础

## MQ优点

### 异步处理

- 相比传统的串行、并行方式，提高系统吞吐量

### 应用解耦

- 系统间通过消息通信，不用关心其他系统的处理

### 流量削锋

- 可以通过消息队列长度控制请求量；可以缓解短时间内高并发请求

### 日志处理

- 解决大量日志传输

### 消息通讯

- 消息队列一般都内置了高效的通信机制，因此可以用在纯消息通讯。比如实现点对点消息队列，或者聊天室

### 主要是：解耦、异步、削锋

- 1.解耦

	- A系统发送数据BCD三个系统，通过接口调用发送。如果E系统也要这个数据呢？那么A系统又要去给这个系统发送消息，A系统就耦合太多系统了。A系统只需要给MQ发送消息，根本不用关系什么系统需要这个数据，需要这个数据的系统自己去消费即可

- 2.异步

	- A系统收到请求，需要在自己本地写库，还需要再BCD三个系统写库，自己本地库要三秒，BCD三个系统分别要300ms，450ms，200ms，这就会导致系统反应过慢。假如A系统连续发送三条消息到MQ队列中，只需要耗时5ms。那么就会大大缩短系统的响应速度

- 3.削锋

	- 减少高峰时期对服务器的压力

## MQ缺点

### 系统可用性降低

- 假如消息队列挂了，那么系统可用性就会降低

### 系统复杂度提高

- 假如消息队列，还需要考虑很多方面的东西，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输。需要考虑的东西很多，复杂性增大

### 一致性问题

- A系统处理完了直接返回成功了，但是BCD系统要同步数据，BC同步成功了D失败了，就会造成一致性问题

## 你们公司生产环境用的什么消息中间件？

### 比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。

但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。

然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。

另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。

而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。

除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。

但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。

然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。

而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。

另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。

但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。

因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。

### 一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；

后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；

不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。

所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。

如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。

## MQ有哪些常见的问题？如何解决这些问题？

### 1.消息的顺序问题

- 图：
- 假如生产者产生了2条消息：M1、M2，假定M1发送到S1，M2发送到S2，如果要保证M1先于M2被消费，怎么做？

	- 保证生产者-MQServer-消费者是一对一对一的关系，如图：

		- 缺陷：

			- 1.并行度就会才成为消息系统的瓶颈(吞吐量不够)
			- 2.更多异常处理，比如：只要消费端出现了问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞问题

	- 通过合理的设计或者将问题分解来规避

		- 1.不关注乱序的应用实际大量存在
		- 2.队列无序并不代表消息无序，所以从业务层面来保证消息的顺序而不是仅仅依赖于消息系统，是一种更合理的方式

### 2.消息的重复问题

- 消息重复问题的根本原因是：网络不可达。如果消费端收到了两条一样的消息应该怎么处理？

	- 消费端处理消息的业务逻辑保持幂等性。只要保证了幂等性，不管来了多少条消息，最后处理的结果都是一样的。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。如果新到的消息ID已经在日志表中，那么就不再处理这条消息

## RabbitMQ

### 简介：RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件

### rabbitMQ的使用场景

- 1.服务间异步通信
- 2.顺序消费
- 3.定时任务
- 4.请求削锋

### RabbitMQ基本概念

- broker：消息队列服务器实体
- exchange：消息交换机，它指定消息按什么规则，路由到那个队列
- queue：消息队列载体，每个消息都会被投入到一个或多个队列
- binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来
- routing key：路由关键字，exchange根据这个关键字进行消息投递
- vhost：vhost可以理解为broker，即mini-rabbitMQ server。其内部均含独立的queue、exchange、binding等，其拥有独立的权限系统，可以做到vhost范围的用户控制
- producer：消息生产者，就是投递消息的程序
- consumer：消息消费者，就是按照接收消息的程序
- channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话

### 工作模式

- simple模式

	- 图：

- work模式(资源的竞争)

	- 图：

- publish/subscribe发布订阅(共享资源)

	- 图：
	- 1.每个消费者监听自己的队列
	- 2.

- routing路由模式
- topic主题模式(路由模式的一种)

