# Redis基础

## 1.概述

### Redis是一个使用C语言编写的，开源的高性能非关系型(NoSQL)的键值数据库。支持五种数据类型字符串、列表、集合、散列表、有序集合。其将数据存储在内存中，读写速度极快，redis被广泛应用于缓存方向，每秒客户处理超过10万次读写操作。redis也经常被用来做分布式锁。除此之外还支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案

- 问题：

	- 1.为什么要用缓存？

		- 支持更好的性能和并发量。
		- 高性能：假设用户第一次访问数据库某些数据。这个过程会比较慢，因为时从数据库读取的。将该用户访问的数据存在缓存中，下次去访问这些数据的时候就可以直接从缓存中获取。直接操作内存，速度极快。数据库对应的数据发生改变的时候，同步改变缓存中响应的数据即可。
		- 高并发：直接操作缓存能够承受的请求远远大于直接访问数据库，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求直接到缓存中获取，而不需要经过数据库

	- 2.为什么要用Redis，不用map/guava做缓存？

		- 缓存可以分为本地缓存和分布式缓存。使用map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着JVM的销毁而结束，并且在多实例(多台服务器)的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
		- 使用Redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。

	- 3.redis为什么这么快？

		- 1.完全基于内存，绝大部分请求都是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间夫再度都是O(1)
		- 2.数据结构简单，对于数据操作也简单
		- 3.采用单线程，避免不必要的上下文切换和竞争条件，也不存在多线程导致的切换消耗CUP，不用考虑各种锁问题
		- 4.采用IO复用模型，非阻塞的IO
		- 5.使用自己构建的VM机制，省去一定时间移动和请求

## 2.数据类型

### Redis数据类型

- 1.String

	- 字符串、整数或者浮点数

		- 操作：可以对字符串整个或部分操作
对整数、浮点数执行自增或自减操作

			- 应用场景：用作简单的键值缓存

- 2.List

	- 从两端压入或者弹出元素

		- 操作：对单个或者多个元素进行修剪，只保留一个范围内的元素

			- 应用场景：存储一些列表型的数据结构，类似粉丝列表、文章评论列表之类的数据

- 3.set

	- 无序集合

		- 操作：添加、获取、溢出单个元素检查一个元素是否存在于集合中，计算交集、并集、差集从集合里面随机获取元素

			- 应用场景：交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整成一个交集

- 4.hash

	- 包换键值对的无需散列表

		- 操作：添加、获取、移除单个键值对获取所有键值对检查某个键是否存在

			- 应用场景：结构化数据，比如一个对象

- 5.zset

	- 有序集合

		- 操作：添加、获取、删除元素，更具分值范围或者成员来获取元素计算一个键的排名

			- 应用场景：去重但可以排序，如获取排名前几名的用户

## 3.应用场景

### 1.计数器

- 适合存储频繁读写的技术量

### 2.缓存

- 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率

### 3.会话缓存

- 可以使用redis存储统一多台应用服务器的会话信息。保证单点登录功能的实现（token）

### 4.全页缓存(不太明白)

- 除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

### 5.查找表(不太实用)

- 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

### 6.消息队列(发布/订阅功能)

- List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。

### 7.分布式锁

- 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

### 8.其他

- Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。

## 4.持久化

### 什么是redis持久化？

- 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失

### redis的持久化方式

- 1.RDB(默认)

	- 按照一定的时间将内存的数据以快照的形式保存到硬盘中，产生的数据文件为dump.rdb。通过save的参数来定义快照的周期

		- rdb图：

- 2.AOF

	- 将redis执行的每次命令记录到单独的日志文件中，当重启redis会才重新将持久化的日志文件回复数据

		- aof图：

### 问题：

- 1.两种方式同时开启，redis会选择哪种方式恢复？

	- 同时开启两种，优先选择AOF

- 2.当数据集比较大时，哪种恢复方式比较好？

	- 数据集比较大的时候选择RDB内存快照的方式恢复会比AOF效率高

- 3.RDB是怎么将内存中的数据持久化到磁盘？

	- fork子进程来完成写操作，让主进程继续处理命令，所以IO最大化。使用单独子进程来持久化，主进程不会进行任何IO操作，保证redis的高性能

- 4.两者比较有什么区别？

	- 1.AOF比RDB文件大，且恢复速度慢
	- 2.AOF更新频率高，RDB采用定时方式更新
	- 3.AOF比RDB更安全也更大
	- 4.RDB性能比AOF好
	- 5.两者都配置了，优先使用AOF

- 5.如何选择持久化方式？

	- 1.对数据完整性要求较高的，优先使用AOF
	- 2.对恢复性能要求比较高的，可以使用RDB

### redis持久化数据和缓存扩容

- redis被使用于缓存，使用一致性哈希实现动态扩容
- redis是使用持久化数据使用，必须使用固定的keys-to-nodes映射关系，节点数量一旦确就不能变化。否则的话(redis节点需要动态变化的情况)，必须使用可以在运行时进行数据平衡的一套系统，只有redis集群可以做到

## 5.过期键值的删除策略

### 过期策略

- 1.定时过期

	- 每个设置过期时间的key都需要创建一个定时器，到过期时间就删除。时间到立即清除数据，对内存友好，但是会占用大量的CPU资源区处理过期的数据，从而影响缓存的响应时间和吞吐量

- 2.惰性过期

	- 当访问时，才会判断key是否过期，过期就清除。该策略最大化节省CPU资源，但是对内存非常不友好。极端情况下，大量过期key没有被使用，不会被清除，占用大量内存

- 3.定期过期

	- 每隔一段时间，会定时扫描一定数量的数据库expires字典中一定数量的key，并清除其中过期的key。是以上两种策略的折中方案。

### redis中同时使用了惰性过期和定期过期两种策略

### 过期时间和永久有效命令

- expire：设置过期时间
persist：永久有效

### 问题：

- 1.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？

	- redis内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略(allkeys-lru)

- 2.redis的内存淘汰策略有哪些？

	- 1.全局的键空间选择性移除

		- ①noeviction：当内存不足以容纳写入的数据时，新写入的操作会报错
		- ②allkeys-lru：当内存不足以容纳写入的数据时，在键空间中，移除最少使用的key。(这个时最常用的)
		- ③allkeys-random：当内存不足以容纳写入的数据时，在键空间中，随机移除某个key

	- 2.设置过期时间的键空间选择性移除

		- ①volatile-lru：当内存不足以容纳新写入的数据时，在设置了过期时间的键空间中，移除最近最少使用的key
		- ②volatile-random：当内存不足以容纳新写入的数据时，在设置了过期时间的键空间中，随机移除某个key
		- ③volatile-ttl：当内存不足以容纳新写入的数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

	- 内存的淘汰策略的选取不会影响过期key的处理

- 3.redis主要消耗什么物理资源？

	- 内存

- 4.redis的内存用完了会发生什么？

	- 达到设置的上限，redis的写命令会返回错误信息(读还是可以的)，可以设置淘汰机制，达到上限时，会删除就的内容

- 5.redis如何做内存优化？

	- 尽可能使用散列表(hash)，散列表使用的内存非常小，所以应该尽可能将数据模型抽象到一个散列表里面。比如web系统中的用户对象，不要为用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面

## 6.线程模型

### Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。

### 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。

### 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

### 虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。

## 7.事务

### 什么是redis的事务？

- 事务中的命令要么全部执行，要么全部不执行

### redis事务的概念

- redis事务的本质是通过multi、exec、watch等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令的序列中。
- 总结：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令

### redis事务的三个阶段

- 1.事务开始multi
- 2.命令入队
- 3.事务执行exec

### 事务执行过程中，如果服务端收到有exec、discard、watch、multi之外的请求，将会把请求放入队列中排队

- 这几个命令同时也是redis事务实现的原理

	- 1.watch命令是一个乐观锁，可以为redis事务的提供check-and-set(CAS)行为。可以监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不会执行，监控一直持续到exec命令
	- 2.multi命令用于开启一个事务，它总是返回ok。multi执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当exec命令被调用时，所有队列的命令才会被执行
	- 3.exec命令用于执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空null
	- 4.discard命令可以清空事务队列，放弃执行事务，并且客户端会从事务状态中退出
	- 5.unwatch命令可以取消watch对所有key的监控

### redis会将一个事务中的所有命令序列化，然后按顺序执行

- 1.redis不支持回滚
- 2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行

	- 命令出现错误，全部的都不会再运行

- 3.如果一个事务在运行中出现了错误，那么正确的命令将会被执行

	- 运行出现错误(命令没有错误)，那么正确的命令将会被继续执行

### ACID概述

- 原子性：事务是一个不可分割的工作单位，事务中的操作要么全都发生，要么全都不发生
- 一致性：事务前后数据的完整性必须保持一直
- 隔离性：多个事务并发执行时，一个事务的执行不影响其他事务的执行
- 持久性：一个事务一旦提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

### 问题：

- 1.redis事务支持隔离性吗？

	- 支持，因为redis是单线程的，并且它保证在执行事务时，不会被事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。

- 2.redis事务保证原子性吗？支持回滚吗？

	- 不支持回滚，不保证原子性，事务中任意命令执行失败，其余命令扔会被执行。

- 3.还可以使用其他方式实现事务吗？

	- 基于lua脚本实现，保证脚本内的命令一次性、按顺序地执行，同时也不提供事务运行错误的回滚，执行如果部分命令运行错误，剩下地命令还是会继续运行完

- 4.如何保证缓存与数据库双写时的数据一致性？

	- 1.先写缓存，再写数据库，缓存写成功，数据库写失败。缓存写成功，但是数据库失败或者响应延迟，则下次读取(并发读)缓存时，就出现了胀读

		- 这种写缓存的方式本来就是错的，需要先写数据库，把旧的缓存设置为失效；读取数据的时候，如果缓存不存在，则读数据库再写缓存

	- 2.先写数据库，再写缓存数据库成功，缓存失败。写数据库成功，但写缓存失败，则下次读取(并发度)缓存时，则读不到数据

		- 缓存使用时，加入读缓存失败，先读数据库，再会写缓存的方式实现。注意需要加锁。

	- 3.需要缓存异步更新。指数据库操作和写缓存不在一个操作步骤中，比如分布式场景下，无法做到同时写缓存或需要异步刷新(补救措施)时候

		- 确定哪些数据合适此场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔

## 8.分布式

### 1.redis如何实现分布式锁？

- 多客户端对redis的连接欸并不存在竞争关系，redis可以使用setnx命令实现分布式锁。

	- setnx命令获取锁，若返回0(key已存在，锁已存在)则获取失败，反之获取成功。为了防止获取锁后台程序出现异常，导致其他线程/进程调用setnx命令总是返回0进入死锁状态，需要为key设置一个合理的过期时间。
释放锁：del命令将锁数据删除

### 2.如何解决redis的并发竞争key问题？

- 描述：所谓redis的并发竞争key问题就是多个系统同时对一个key进行操作问题，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同
- 方案：分布式锁(zookeeper和redis都可以实现分布式锁，如果不存在redis的并发竞争key问题，不要使用分布式锁，这样会影响性能）

实践中，从可靠性为主。首推zookeeper

	- zookeeper临时有序节点可以实现分布式锁。每个客户端对某个方法加锁时，在zookeeper上该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需要将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，产生死锁问题。完成业务流程后，删除对应的子节点的释放锁。

### 3.什么是RedLock？

- redis官方推出的redis实现分布式锁的方式，这种方式比原先更简单，方法更安全。它有于以下特征：

	- 1.安全特性

		- 互斥访问，即永远只有一个client能拿到锁

	- 2.避免死锁

		- 最终client都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源client crash(宕机或者坏掉了)或者出现了网络分区

	- 3.容错性

		- 只要大部分redis节点存存活就可以正常提供服务

	- 提示：获取锁

		- Redisson类包

## 9.缓存异常

### 1.缓存雪崩

- 描述：指缓存同一时间内大面积失效或者redis服务器挂掉。所以，后面的请求都会落到数据库上，照成数据库短时间内承受大量的请求而崩掉
- 解决方案：

	- 1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
	- 2.一般并发量不是特别多的时候，使用最多的解决方案时加锁排队。
	- 3.给每一个缓存的是数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。
	- 4.防止服务器宕机，最好最好redis主备服务

### 2.缓存穿透

- 描述：指缓存中没有数据，导致所有请求都落到数据库上，造成数据库短时间承受大量请求而崩掉
- 解决方案：

	- 1.接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截
	- 2.从缓存取不到的数据，在数据库中也没有取到，这是可以将key-value对写为key-null，缓存有效时间可以设置短一点，如30s。这样可以防止攻击用户反复用同一个id暴力攻击
	- 3.采用布隆过滤器。或者将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力

### 3.缓存击穿

- 描述：指缓存中没有但数据库中有的数据(一般指缓存时间到期)，这时由于并发用户特别多，同时读取缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成压力过大。和缓存雪崩不同的是，缓存击穿指并发查一条数据，缓存雪崩式不同数据都过期了，很多数据查不到。
- 解决方案：

	- 1.设置热点数据永不过期
	- 2.加互斥锁

### 4.缓存预热

- 描述：系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查数据库，然后再将数据缓存问题！
- 解决方案：

	- 1.直接写个缓存刷新页面，上线时手工操作一下
	- 2.数据量不大，可以在项目启动的时候自动进行加载
	- 3.定时刷新缓存

### 5.缓存降级

- 当访问量剧增、服务器出现问题(如响应慢或者不响应)或非核心服务影响到核心服务。
- 服务降级的目的，是为了防止redis服务故障，导致数据库跟着一起发生雪崩问题。比较常见的一个做法就是不去数据库查询，直接返回默认值个i用户

### 6.缓存热点key

- 缓存中的一个key，在某个时间点过期的时候，恰好在这个时间点对这个key有大量的并发请求，大量请求可能会瞬间吧DB数据压垮
- 解决方案：

	- 对缓存查询加锁，如果key不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据

## 10.常用工具

### Redisson、Jedis、lettuce等等，官方推荐使用Redisson。

### redis和redisson有什么关系？

- redisson是一个高级的分布式协调redis客户端，能帮助用户在分布式环境中轻松实现一些Java的对象

	- 对象：

		- Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog

### Jedis和Redisson对比有什么优缺点？

- Jedis是redis的Java实现客户端，其API提供了比较全面的redis命令支持；Redisson实现了分布式和可扩展的Java数据结构，Jedis相比，功能较为简单，不支持字符串此操作，不支持排序、事务、管道、分区等Redis特性。Redisson促使使用者对redis的关注分离，从而让使用者能够将经理更集中在处理业务逻辑上

## 11.集群方案

### 1.哨兵模式

- 图：
- 介绍：

	- sentinel，中文名是哨兵。哨兵是redis集群机构中非常重要的一个组件，主要有以下功能：

		- 1.集群监控

			- 负责监控redis master和slave进程是否正常工作

		- 2.消息通知

			- 如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员

		- 3.故障转移

			- 如果master node挂掉了，会自动转移到slave node上

		- 4.配置中心

			- 如果故障转移发生了，，通知client客户端新的master地址

	- 哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。

		- 故障转移时，判断一个master node是否宕机了，需要大部分哨兵都统一才行，涉及了分布式选举问题
		- 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的

- 哨兵核心知识：

	- 1.哨兵至少需要三个实例来保证健壮性
	- 2.哨兵+redis主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性
	- 3.对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练

### 2.官方Redis Cluster方案(服务端路由查询)

- 图：
- redis集群模式的工作原理能说一下吗？在集群模式下，redis的key怎么寻址？分布式寻址都有那些算法？了解一致性hash算法吗？
- 简介：

	- redis cluster是一种服务端的Sharding技术，3.0版本开始正式提供。redis cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收请求的节点会将查询请求发送到正确的节点上执行

- 方案说明：

	- 1.通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384个槽
	- 2.每份数据分片会存储在多个护卫主从的多节点上
	- 3.数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)
	- 4.同一分片多个节点间的数据不保持一致性
	- 5.读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
	- 6.扩容时需要把旧节点的数据迁移一部分到新节点
	- #在redis cluster架构下，每个redis都要放开两个端口，比如一个6379，另一个就是加1w的端口号16379。

16379端口号是用来进行节点间通信的，也就是cluster bus的东西，cluster bus的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus用了另一种二进制协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间

- 节点间的内部通信机制

	- 集群元数据的维护有两种方式：集中式、gossip协议。redis cluster节点间采用gossip协议进行通信

- 分布式寻址算法

	- 1.hash算法(大量缓存重建)
	- 2.一致性hash算法(自动缓存迁移)+虚拟节点(自动负载均衡)
	- 3.redis cluster的hash slot算法

- 优点：

	- 1.无中心架构，支持动态扩容，对业务透明
	- 2.具备Sentinel的监控和自动Failover(故障转移)能力
	- 3.客户端不需要链接集群的所有节点，连接集群中任何一个可用节点即可
	- 4.高性能，客户端直连redis服务，免去了proxy代理的损耗

- 缺点：

	- 1.运维也很复杂，数据迁移需要人工干预
	- 2.只能使用0号数据库
	- 3.不支持批量操作
	- 4.分布式逻辑和存储模块耦合

### 3.基于客户端分配

- 图：
- 简介：

	- redis sharding是redis cluster出来之前，业界普遍使用的多redis实例集群方法。其主要思想采用哈希算法将redis数据的key进行散列，通过hash函数，特定的key会映射到特定的redis节点上。java redis客户端驱动jedis，支持redis sharding功能，即shardedJedis以及结合缓存池的sharedJedisPool

- 优点：

	- 优势在于非常简单，服务端的redis实例彼此独立，相互无关联，每个redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强

- 缺点：

	- 1.由于sharding处理放在客户端，规模进一步扩大时给运维带来挑战
	- 2.客户端sharding不支持动态增删节点。服务端redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，应当应用规模更大时，资源浪费制约优化

### 4.基于代理服务器分片

- 图：
- 简介：

	- 客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端

- 特征：

	- 1.透明接入，业务程序不用关心后端redis实例，切换成本低
	- 2.Proxy的逻辑和存储的逻辑是隔离的
	- 3.代理层多了一次转发，性能有所损耗

- 业界开源方案

	- 1.Twtter开源的Twemproxy
	- 2.豌豆荚开源的Codis

## 12.redis主从架构

### 图：

### 简介：

- 对于缓存来说，都是用来支撑读高并发的。因此架构做成主从架构，一主多从，主负责写，从负责读。可以轻松实现水平扩容，支撑读高并发

### redis replication的核心机制

- 简述：redis replication->主从架构->读写分离->水平扩容支撑高并发
- 1.redis采用异步方式复制数据到slave节点上，2.8以后slave node会周期性地确认自己每次复制的数据量
- 2.一个master node是可以配置多个slave node的
- 3.slave node也可以连接其他的slave node的
- 4.slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧的数据集，加载新数据集，这个时候就会暂停对外服务
- 5.slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量
- 注意：需要开启master node的持久化，防止master宕机重启以后数据是空的，导致从节点也变成空的

### 主从复制核心原理

- 图：
- 过程原理：

	- 1.启动slave node的时候，它会发送一个PSYNC命令给master node
	- 2.如果这是slave node初次连接到master node，那么就会触发一次full resynchronization全量复制。此时master会启动一个后台线程，开始生成一份份RDB快照文件，同时还会将从客户端client新收到的所有命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送到slave，slave也会同步这些数据
	- 3.slave node如果跟master node有网络故障，断开连接，会自动重连，连接之后master node仅会复制给slave部分缺少的数据

- 缺点：

	- 所有的slave节点数据的复制和同步都有master节点来处理，会造成master节点压力太大，使用主从从结构来解决

## 13.分区

### redis是单线程的，如何提高多核cpu的利用率？

- 可以在同一个服务器部署多个redis实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以，如果你想使用多个cpu，你可以考虑以下分片(shard)

### 为什么要做redis分区？

- 分区可以让redis管理更大的内存，redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使redis的计算能力通过简单的增加计算机得到成倍提升，redis网络带宽也会随着计算机和网卡的增加而成倍增长

### 你知道有哪些redis分区方案?

- 1.客户端分区就是在客户端就已经决定数据会被存储到那个redis节点或者从哪个redis节点读取。大多数客户端已经实现了额客户端分区
- 2.代理分区意味着客户端将请求发送给代理，然后代理决定去那个节点写数据或者读数据。代理根据分区规则决定请求那些redis实例，然后根据redis的响应结果返回给客户端。redis和memcacheed的一种代理实现就是Twemproxy
- 3.查询路由(query routing)的意思是客户端随机请求任意一个redis实例，然后由redis将请求转发给正确的redis节点。redis cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis系欸但转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点

### redis分区有什么缺点？

- 1.涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为被他们可能被存储在不同的redis实例(有办法，但是不能直接使用交集指令)
- 2.同时操作多个key，则不能使用redis事务
- 3.分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集
- 4.当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的redis实例和主机同时收集RDB/AOF文件
- 5.分区时动态扩容或缩容可能非常复杂。redis集群在运行时增加或者删除redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片地技术也可以较好地解决这个问题

## 实际场景

### redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。

机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。

5 台机器对外提供读写，一共有 50g 内存。

因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。

你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。

其实大型的公司，会有基础架构的 team 负责缓存集群的运维。

## 问题

### 说说redis哈希槽的概念？

- redis集群没有使用一致性hash，而是引入了哈希槽的概念，redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置那个槽，集群每个节点负责一部分hash槽

### redis集群会有写操作丢失吗？为什么？

- redis并不能保证数据的强一致性，这意味着这在实际中集群再特定的条件下可能胡丢失写操作

### redis集群之间是如何复制的？

- 异步复制

### redis集群最大节点个数是多少？

- 16384个

### redis集群如何选择数据库？

- redis目前无法做数据库选择，默认在0数据库

### redis常见的性能问题和解决方案？

- 1.Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化

	- 和主从复制原理似乎有点冲突

- 2.如果数据比较关键，某个slave开启AOF备份数据，策略为每秒同步一次
- 3.为了主从复制的速度和连接的稳定性，slave和master最好在同一个局域网内
- 4.尽量避免在压力较大的主库上增加从库
- 5.master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占用大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象
- 6.为了master的稳定性，主从复制不要用图状结构，用单链表结构更稳定，即主从关系为：master<-slave1<-slave2<-slave3...，这样的结构也方便解决单点故障问题，实现slave对master的替换，如果master挂了，可以立马启用slave1做master，其他不变

### 一个字符串类型的值能存最大容量是大少？

- 512M

### Redis如何做大量的数据插入？

- redsi2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作

### 假如redis里面有1亿个key，其中有10w个key是以某个固定的已知的1前缀开头的，如何将它们全部找出来？

- 使用keys指令可以扫出指定模式的key列表
例：查找cjh开头的key, keys cjh*
- 因为redis是单线程的，所以keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan命令可以无阻塞地提取指定模式的key列表，但是会有一定的重复概率，在客户端就做一次去重就行了，但是整体所华为的时间会比直接用keys指令长

### 如何使用redis做异步队列？

- 使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息是，可以sleep一段时间，然后再检查有没有信息，不想sleep的话，可以使用blpop，没有信息的时候会一直阻塞，直到消息来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当消费者下线时，生产的消息会丢失

### redis如何实现延迟队列？

- 使用sortedset，使用时间戳做score，消息内容作为key，调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理

### redis回收线程如何工作？

- 1.一个客户端运行了新的命令，添加了新的数据
- 2.redis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收。
- 3.一个新的命令被执行，等等
- 4.所以我们不断地穿越内存限制地边界，通过不断达到边界然后不断回收边界一下

### redis回收使用的算法是什么？

- LRU算法

